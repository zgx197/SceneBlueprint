# SceneBlueprint 数据流节点系统设计

**版本**: v1.0  
**日期**: 2026-02-16  
**状态**: ✅ Phase 1-3 已完成，待验证测试

---

## 一、设计目标

### 1.1 核心理念

**SceneBlueprint = 声明式配置工具**
- 用节点图描述"在什么条件下，做什么事"
- 导出为 Playbook（JSON 配置）
- 运行时 System 读取配置并执行具体逻辑

### 1.2 为什么需要数据流？

**问题**：当前纯控制流设计的局限性
```
[Spawn.Wave]
  ├─ locationStrategy: RandomArea  ❌ 配置耦合
  ├─ rhythmStrategy: Waves         ❌ 难以复用
  ├─ monsters: [...]               ❌ 节点臃肿
  └─ effects: [...]                ❌ 特效耦合
```

**解决方案**：节点组合 + 数据流
```
[Location.RandomArea] ──positions──┐
[Monster.Pool]       ──monsters───┼→ [Spawn.Execute] ──→ [VFX.ScreenFlash]
[Rhythm.Waves]       ──rhythm─────┘
```

**收益**：
- ✅ 节点职责单一
- ✅ 策略可复用（Location 可用于刷怪、道具生成、NPC 放置）
- ✅ 特效独立（可任意组合）
- ✅ 蓝图可视化清晰

---

## 二、端口系统扩展

### 2.1 端口类型（PortKind）

```csharp
public enum PortKind
{
    Flow,    // 控制流：决定执行顺序（黑色线）
    Event,   // 事件流：触发后续节点（橙色线）
    Data     // 数据流：传递配置或状态（蓝色线）
}
```

**区别**：
- **Flow**：同步执行，一进一出
- **Event**：异步触发，可以多次触发
- **Data**：不影响执行，只提供数据

### 2.2 端口方向（PortDirection）

```csharp
public enum PortDirection
{
    Input,   // 输入端口
    Output   // 输出端口
}
```

### 2.3 数据类型声明

```csharp
public class PortDefinition
{
    public string Id;                // 端口 ID
    public string DisplayName;       // 显示名称
    public PortKind Kind;            // 端口类型
    public PortDirection Direction;  // 方向
    
    // 数据端口专用
    public string DataType;          // 数据类型（如 "Vector3[]"）
    public bool Required;            // 是否必需（默认 false）
    public string Description;       // 描述文本
}
```

### 2.4 预定义数据类型

```csharp
public static class DataTypes
{
    // 基础类型
    public const string Float = "float";
    public const string Int = "int";
    public const string Bool = "bool";
    public const string String = "string";
    
    // Unity 类型
    public const string Vector3 = "Vector3";
    public const string Vector3Array = "Vector3[]";
    public const string Transform = "Transform";
    
    // 自定义类型
    public const string EntityRef = "EntityRef";
    public const string EntityRefArray = "EntityRef[]";
    public const string MonsterConfig = "MonsterConfig";
    public const string MonsterConfigArray = "MonsterConfig[]";
    public const string RhythmData = "RhythmData";
    public const string AreaData = "AreaData";
}
```

---

## 三、连线验证规则

### 3.1 基础规则

| 规则 | 描述 | 强制性 |
|------|------|--------|
| **R1** | 同类型端口才能连接（Flow→Flow, Data→Data） | ✅ 强制 |
| **R2** | 方向必须匹配（Output → Input） | ✅ 强制 |
| **R3** | Data 端口必须类型兼容 | ✅ 强制 |
| **R4** | Required 的 Data 输入端口必须连接 | ⚠️ 警告 |
| **R5** | Flow 输入端口只能连一条线 | ✅ 强制 |
| **R6** | Flow/Event 输出端口可以连多条线 | ✅ 允许 |
| **R7** | Data 输入端口只能连一条线 | ✅ 强制 |
| **R8** | Data 输出端口可以连多条线 | ✅ 允许 |

### 3.2 类型兼容性判断

```
精确匹配：
  Vector3 → Vector3               ✅ 允许

数组类型：
  Vector3[] → Vector3[]           ✅ 允许
  Vector3 → Vector3[]             ❌ 禁止（不自动包装）

子类型（未来扩展）：
  MonsterConfig → UnitConfig      ✅ 允许（如果继承关系成立）

类型不匹配：
  Vector3 → EntityRef             ❌ 禁止
  Vector3[] → MonsterConfig[]     ❌ 禁止
```

**实现**：
```csharp
public static bool IsCompatible(string sourceType, string targetType)
{
    // 精确匹配
    if (sourceType == targetType)
        return true;
    
    // 未来：子类型检查
    // if (IsSubTypeOf(sourceType, targetType))
    //     return true;
    
    return false;
}
```

### 3.3 编辑器交互

**拖动连线时**：
1. 高亮所有兼容的端口（发光效果）
2. 灰显不兼容的端口
3. 鼠标悬停在不兼容端口时，显示错误提示
   ```
   ❌ 类型不匹配
   源端口: Vector3[]
   目标端口: MonsterConfig[]
   ```

**连线后验证**：
1. 检查类型兼容性
2. 不兼容时**阻止连线**并弹出错误提示
3. 在节点上显示错误标记（红色感叹号）

**必需性检查**：
1. 保存蓝图时检查所有 `Required = true` 的 Data 输入端口
2. 未连接的必需端口显示警告（⚠️）
3. 可以保存，但在问题面板中列出警告

---

## 四、节点分类设计

### 4.1 配置提供节点（Provider）

**职责**：生成静态配置数据

**特征**：
- 无 Flow 输入端口（不需要触发）
- 只有 Data 输出端口
- 编辑时就能确定输出

**典型节点**：

#### Location.RandomArea
```
输出：
  - positions: Vector3[]

属性：
  - area: SceneBinding (Area)
  - count: int (数量)
```

#### Location.PresetPoints
```
输出：
  - positions: Vector3[]

属性：
  - points: SceneBinding (Transform)
```

#### Monster.Pool
```
输出：
  - monsters: MonsterConfig[]

属性：
  - configs: MonsterConfig[] (列表)
```

#### Rhythm.Waves
```
输出：
  - rhythm: RhythmData

属性：
  - waveCount: int
  - waveInterval: float
```

---

### 4.2 执行节点（Executor）

**职责**：执行具体的游戏逻辑

**特征**：
- 有 Flow 输入/输出端口
- 可以有 Data 输入端口（接收配置）
- 可以有 Data 输出端口（输出运行时状态）
- 可以有 Event 输出端口（触发后续事件）

**典型节点**：

#### Spawn.Execute
```
输入（Flow）：
  - in: Flow

输入（Data）：
  - positions: Vector3[] (Required)
  - monsters: MonsterConfig[] (Required)
  - rhythm: RhythmData (可选)

输出（Flow）：
  - out: Flow

输出（Event）：
  - onWaveComplete: Event (每波完成)
  - onAllComplete: Event (全部完成)

输出（Data）：
  - spawnedEntities: EntityRef[]

属性：
  - spawnDelay: float (延迟)
```

**蓝图示例**：
```
[Location.RandomArea] ──positions──┐
[Monster.Pool]       ──monsters───┼→ [Spawn.Execute] ─out→ [VFX.ScreenFlash]
                                        │
                                        └─onAllComplete→ [Spawn: Boss]
```

---

### 4.3 条件节点（Condition）

**职责**：监听运行时状态，条件满足时触发

**特征**：
- 有 Flow 输入端口（开始监听）
- 有 Data 输入端口（监听对象）
- 有 Event 输出端口（条件满足时触发）
- 无 Flow 输出端口（不是同步流程）

**典型节点**：

#### Condition.AllDead
```
输入（Flow）：
  - in: Flow (开始监听)

输入（Data）：
  - entities: EntityRef[] (Required)

输出（Event）：
  - onAllDead: Event

属性：
  - checkInterval: float (检查间隔)
```

**蓝图示例**：
```
[Spawn.Execute] ─spawnedEntities→ [Condition.AllDead] ─onAllDead→ [Spawn: Boss]
                └─out→ [VFX.ScreenFlash]
```

---

### 4.4 特效节点（VFX）

**职责**：播放视觉/听觉特效

**特征**：
- 有 Flow 输入/输出端口
- 可以有 Data 输入端口（接收参数，如位置）
- 无 Data 输出端口

**典型节点**：

#### VFX.ScreenFlash
```
输入（Flow）：
  - in: Flow

输出（Flow）：
  - out: Flow

属性：
  - color: Color
  - duration: float
  - intensity: float
```

#### VFX.CameraShake
```
输入（Flow）：
  - in: Flow

输入（Data，可选）：
  - epicenter: Vector3 (震中位置)

输出（Flow）：
  - out: Flow

属性：
  - intensity: float
  - duration: float
```

---

### 4.5 触发节点（Trigger）

**职责**：监听游戏事件，作为蓝图的入口

**特征**：
- 无 Flow 输入端口（由运行时触发）
- 有 Flow 输出端口
- 可以有 Event 输出端口（重复触发）

**典型节点**：

#### Trigger.EnterArea
```
输出（Flow）：
  - out: Flow (首次进入)

输出（Event）：
  - onReEnter: Event (重复进入)

属性：
  - area: SceneBinding (Area)
  - triggerMode: Enum (Once, Multiple)
```

---

## 五、典型蓝图场景

### 5.1 简单刷怪

```
[Trigger.EnterArea] ──┐
                      │
[Location.RandomArea]─┼─positions─┐
[Monster.Pool]       ─┼─monsters──┼→ [Spawn.Execute] ──→ [VFX.ScreenFlash]
```

**语义**：
- 玩家进入区域
- 在指定区域随机位置
- 刷出配置的怪物
- 播放闪屏特效

---

### 5.2 波次刷怪 + 条件触发

```
[Trigger.EnterArea] ──┐
                      │
[Location.RandomArea]─┼─positions─┐
[Monster.Pool: 小怪] ─┼─monsters──┼→ [Spawn.Execute: 第一波] ─┬─out→ [VFX]
[Rhythm.Waves]       ─┼─rhythm────┘                           │
                                                               └─spawnedEntities─┐
                                                                                 │
                                    [Location.PresetPoints]─positions─┐         │
                                    [Monster.Pool: Boss]   ─monsters──┼→ [Spawn.Execute: Boss]
                                                                       │         │
                                    [Condition.AllDead]←──────entities─┘         │
                                           │                                     │
                                           └─onAllDead→────────in───────────────┘
```

**语义**：
1. 玩家进入区域，触发第一波刷怪（小怪）
2. 第一波刷怪完成后，播放特效
3. 同时，Condition.AllDead 开始监听第一波怪物
4. 当第一波怪物全部死亡时，触发 Boss 刷怪

---

### 5.3 复杂特效组合

```
[Spawn.Execute] ─out→ [VFX.ScreenFlash]
                 │
                 ├─→ [VFX.CameraShake]
                 │
                 └─→ [Audio.PlaySFX]
```

**语义**：
- 刷怪完成后，并行触发多个特效
- 闪屏 + 震屏 + 音效

---

## 六、编辑器实现要点

### 6.1 端口定义语法糖

```csharp
// 便捷方法
public static class Port
{
    public static PortDefinition In(string id, string displayName = null)
        => new PortDefinition
        {
            Id = id,
            DisplayName = displayName ?? id,
            Kind = PortKind.Flow,
            Direction = PortDirection.Input
        };
    
    public static PortDefinition Out(string id, string displayName = null)
        => new PortDefinition
        {
            Id = id,
            DisplayName = displayName ?? id,
            Kind = PortKind.Flow,
            Direction = PortDirection.Output
        };
    
    public static PortDefinition Event(string id, string displayName = null)
        => new PortDefinition
        {
            Id = id,
            DisplayName = displayName ?? id,
            Kind = PortKind.Event,
            Direction = PortDirection.Output
        };
    
    public static PortDefinition DataIn(string id, string displayName, 
        string dataType, bool required = false, string description = null)
        => new PortDefinition
        {
            Id = id,
            DisplayName = displayName,
            Kind = PortKind.Data,
            Direction = PortDirection.Input,
            DataType = dataType,
            Required = required,
            Description = description
        };
    
    public static PortDefinition DataOut(string id, string displayName, 
        string dataType, string description = null)
        => new PortDefinition
        {
            Id = id,
            DisplayName = displayName,
            Kind = PortKind.Data,
            Direction = PortDirection.Output,
            DataType = dataType,
            Description = description
        };
}
```

### 6.2 连线验证逻辑

```csharp
public class ConnectionValidator
{
    public ValidationResult ValidateConnection(
        PortDefinition sourcePort, 
        PortDefinition targetPort)
    {
        // R1: 同类型端口才能连接
        if (sourcePort.Kind != targetPort.Kind)
            return ValidationResult.Error("端口类型不匹配");
        
        // R2: 方向必须匹配
        if (sourcePort.Direction != PortDirection.Output)
            return ValidationResult.Error("源端口必须是输出端口");
        if (targetPort.Direction != PortDirection.Input)
            return ValidationResult.Error("目标端口必须是输入端口");
        
        // R3: Data 端口类型兼容性
        if (sourcePort.Kind == PortKind.Data)
        {
            if (!IsTypeCompatible(sourcePort.DataType, targetPort.DataType))
                return ValidationResult.Error(
                    $"数据类型不兼容：{sourcePort.DataType} → {targetPort.DataType}");
        }
        
        return ValidationResult.Success();
    }
    
    public bool IsTypeCompatible(string sourceType, string targetType)
    {
        return sourceType == targetType;
        // 未来：支持子类型
    }
}
```

### 6.3 必需性检查

```csharp
public class BlueprintValidator
{
    public IssueReport ValidateBlueprint(SceneBlueprintData blueprint)
    {
        var issues = new List<Issue>();
        
        foreach (var node in blueprint.Nodes)
        {
            var definition = ActionRegistry.Get(node.TypeId);
            
            foreach (var port in definition.Ports)
            {
                // 检查必需的 Data 输入端口
                if (port.Kind == PortKind.Data 
                    && port.Direction == PortDirection.Input 
                    && port.Required)
                {
                    var isConnected = blueprint.Edges.Any(e => 
                        e.TargetNodeId == node.Id && e.TargetPortId == port.Id);
                    
                    if (!isConnected)
                    {
                        issues.Add(new Issue
                        {
                            Severity = IssueSeverity.Warning,
                            NodeId = node.Id,
                            Message = $"必需的数据端口 '{port.DisplayName}' 未连接"
                        });
                    }
                }
            }
        }
        
        return new IssueReport(issues);
    }
}
```

### 6.4 端口渲染

**视觉区分**（✅ 已实现）：
- **Control 端口**：白色圆形 (#FFFFFF)，线条白色
- **Event 端口**：橙色圆形 (#FF9933)，线条橙色
- **Data 端口**：蓝色圆形 (#6BB5FF)，线条蓝色

**连线高亮**（✅ 已实现）：
- 拖线时，兼容端口显示**绿色脉冲动画**（呼吸效果）
- 不兼容端口保持原色，不高亮

**鼠标悬停提示**（✅ 已实现）：
```
控制流 (Control) - 输入 (Input)
类型: exec

数据 (Data) - 输出 (Output)
类型: Vector3[]
```

**实现代码**（参考）：
```csharp
// BaseFrameBuilder.cs - 判断兼容性
var dragHandler = viewModel.GetHandler<ConnectionDragHandler>();
var dragSourcePort = dragHandler?.DragSourcePort;

if (dragSourcePort != null && port.Id != dragSourcePort.Id)
{
    var policy = viewModel.Graph.Settings.ConnectionPolicy;
    var result = policy.CanConnect(viewModel.Graph, dragSourcePort, port);
    canConnect = result == ConnectionResult.Success;
}

// UnityGraphRenderer.cs - 渲染脉冲光效
if (port.CanConnectToDragSource)
    DrawPortCompatibleGlow(wCenter, theme); // 绿色脉冲动画
```

---

## 七、数据结构设计

### 7.1 端口定义

```csharp
[Serializable]
public class PortDefinition
{
    public string Id;
    public string DisplayName;
    public PortKind Kind;
    public PortDirection Direction;
    
    // Data 端口专用
    public string DataType;
    public bool Required;
    public string Description;
}
```

### 7.2 边（连线）定义

```csharp
[Serializable]
public class EdgeData
{
    public string SourceNodeId;
    public string SourcePortId;
    public string TargetNodeId;
    public string TargetPortId;
    
    // 元数据（用于验证和渲染）
    public PortKind Kind;           // 连线类型
    public string DataType;         // Data 连线的数据类型
}
```

### 7.3 节点定义扩展

```csharp
public class ActionDefinition
{
    // 现有字段...
    public string TypeId;
    public string DisplayName;
    public string Category;
    public PortDefinition[] Ports;  // ✅ 替换现有的 Ports 数组
    public PropertyDefinition[] Properties;
    // ...
}
```

---

## 八、实施路线

### Phase 1：核心扩展（3 天）✅ **已完成**

**目标**：支持 Data 端口和连线验证

- [x] 扩展 `PortDefinition` 增加 `DataType`、`Required` 字段
- [x] 扩展 `EdgeData` 增加 `Kind`、`DataType` 字段  
- [x] 实现 `ConnectionValidator` 强制类型检查
- [x] 更新编辑器连线逻辑，集成验证器
- [x] 实现端口高亮和错误提示 UI

**实施日期**：2026-02-16  
**实际耗时**：1 天

### Phase 2：节点重构（2 天）✅ **已完成**

**目标**：实现典型数据流节点

- [x] 实现 `Location.RandomArea`（Provider 节点，输出 Vector3[] 位置列表）
- [x] 实现 `Monster.Pool`（Provider 节点，输出 MonsterConfig[] 配置）
- [x] 改造 `Spawn.Execute`（Executor 节点，Data 输入 + Flow 控制）
- [x] 实现 `Condition.AllDead`（Condition 节点，监听实体死亡）

**实施日期**：2026-02-16  
**实际耗时**：1 天

### Phase 3：编辑器优化（2 天）✅ **已完成**

**目标**：提升用户体验

- [x] 端口视觉区分（Control 白色、Event 橙色、Data 蓝色）
- [x] 连线颜色区分（连线跟随源端口颜色）
- [x] 拖线时高亮兼容端口（绿色脉冲动画）
- [x] 鼠标悬停显示端口类型信息（Kind + Direction + DataType）
- [x] 菜单整合和中英文双语化

**实施日期**：2026-02-16  
**实际耗时**：0.5 天

**额外完成**：
- [x] 修复所有节点端口定义问题（Flow.Start、Trigger.EnterArea、Spawn.Wave、Flow.Join）
- [x] 统一 Control 输出端口为 Multiple 容量（支持并行触发）

### Phase 4：测试验证（1 天）⏳ **待验证**

**目标**：验证设计可行性

- [ ] 构建典型刷怪场景蓝图
- [ ] 验证连线规则正确性
- [ ] 压力测试（复杂图）

**总计：预计 8 天 → 实际 2.5 天**

---

## 九、设计决策记录

### 9.1 为什么强制类型检查？

**决策**：不兼容的连线必须阻止

**理由**：
- SceneBlueprint 是策划工具，需要尽早发现错误
- 运行时才发现类型错误会严重影响迭代效率
- 编辑器可以提供更好的提示和文档

### 9.2 为什么不支持类型自动转换？

**决策**：不支持 `Vector3 → Vector3[]` 等自动包装

**理由**：
- 保持类型系统简单
- 避免隐式行为带来的困惑
- 策划应该明确数据流向

**未来扩展**：
- 可以考虑显式的"转换节点"（如 `Converter.ToArray`）

### 9.3 为什么区分 Flow 和 Event？

**决策**：Flow 是同步流，Event 是异步触发

**理由**：
- Flow 表达明确的执行顺序
- Event 表达运行时动态触发（如"全部死亡"）
- 视觉上区分有助于理解蓝图语义

### 9.4 为什么 Provider 节点无 Flow 输入？

**决策**：配置节点不需要触发

**理由**：
- 它们只提供静态配置，不是"执行"
- 简化蓝图（少一条连线）
- 未来可以考虑"惰性求值"优化

---

## 十、待讨论问题

### 10.1 配置节点的导出策略

**问题**：`Location.RandomArea` 等节点在导出时如何处理？

**选项 A**：导出时内联到使用它的节点
```json
{
  "type": "Spawn.Execute",
  "config": {
    "positions": { "strategy": "RandomArea", "area": "..." }
  }
}
```

**选项 B**：保留独立节点，运行时解析
```json
{
  "nodes": [
    { "id": "loc1", "type": "Location.RandomArea", ... },
    { "id": "spawn1", "type": "Spawn.Execute", ... }
  ],
  "edges": [
    { "from": "loc1.positions", "to": "spawn1.positions" }
  ]
}
```

**倾向**：待确定（需要结合运行时设计决策）

---

### 10.2 是否需要泛型支持？

**问题**：是否需要 `Array<T>` 这样的泛型类型？

**当前方案**：预定义具体类型（如 `Vector3[]`、`EntityRef[]`）

**优点**：简单，类型检查直接
**缺点**：每种数组类型都要预定义

**未来扩展**：可以考虑泛型，但增加复杂度

---

### 10.3 循环引用检测

**问题**：数据端口是否会产生循环依赖？

**示例**：
```
[NodeA] ─data→ [NodeB] ─data→ [NodeA]  ❌ 循环
```

**解决方案**：
- 拓扑排序检测
- 连线时实时检测并阻止

**优先级**：中（Phase 3 实现）

---

## 十一、参考资料

### 11.1 业界案例

- **Unreal Blueprint**：Flow + Data 双向流
- **Unity Visual Scripting**：强类型系统
- **Houdini**：节点组合生成几何体
- **Shader Graph**：数据流为主

### 11.2 相关文档

- `主线速览.md`：SceneBlueprint 整体架构
- `Playbook概念与示例.md`：运行时数据格式
- `SceneMarker系统设计.md`：场景标记绑定

---

**文档版本历史**：
- v0.1 (2026-02-16 上午): 初稿，定义核心概念和设计方向
- v1.0 (2026-02-16 下午): Phase 1-3 实施完成
  - ✅ 核心端口系统扩展（Data/Event/Control 三种类型）
  - ✅ 连线验证器实现（类型检查、方向检查、容量检查）
  - ✅ 4 个典型数据流节点实现（Location/Monster/Spawn/Condition）
  - ✅ UI 增强（端口颜色、连线颜色、拖线高亮、悬停提示）
  - ✅ 修复所有节点端口定义，统一并行触发设计
