# 场景蓝图系统总体设计（SceneBlueprint）

> 版本：v1.0  
> 日期：2026-02-12  
> 状态：设计阶段

---

## 1. 系统愿景

**场景蓝图（SceneBlueprint）** 是一套基于 NodeGraph 框架的可视化场景编排系统，用于在 Unity 编辑器中以节点图的方式编排场景内的一切事件——战斗、环境变化、摄像机控制、特效、叙事等。

核心理念：**Everything is an Action**——场景中每一个可执行的行为都是一个"行动"节点，通过连线表达执行顺序和条件关系。

### 1.1 设计哲学

借鉴 UE GAS（Gameplay Ability System）的核心哲学，但针对"场景编排"而非"实体能力"重新定义：

| GAS 哲学 | 场景蓝图的体现 |
|----------|--------------|
| 数据驱动 | 行动类型通过 ActionDefinition 数据声明，非硬编码 |
| 组合优于继承 | 复杂行为通过图的拓扑组合表达，而非单个巨型节点 |
| 标签驱动条件 | Tag 系统用于条件匹配、行动筛选、事件过滤 |
| 表现与逻辑分离 | Camera/VFX/Audio 作为独立 Action 类型编排 |

### 1.2 与 GAS 的区别

```
GAS (Gameplay Ability System)           SceneBlueprint
──────────────────────────              ──────────────────────────
以"实体"为中心                          以"场景/关卡"为中心
"角色能做什么"                          "场景里会发生什么"
Entity → owns → Abilities              Scene → contains → Actions
运行时动态触发（玩家按键、受击）          编辑时预编排 + 运行时条件触发
```

---

## 2. 系统命名与范围

**系统名：SceneBlueprint（场景蓝图）**

范围：场景内一切可编排的事件。具体用途实例包括：
- 战斗蓝图（刷怪、Boss 战、增援）
- 环境蓝图（灯光、天气、地形变化）
- 叙事蓝图（对话、过场、任务提示）

命名选择理由：
- "Scene" 足够宽——战斗、灯光、天气、过场都是场景内事件
- "Blueprint" 保持与 UE 的概念对齐
- 未来可以有 CombatBlueprint、EnvironmentBlueprint、NarrativeBlueprint 等具体用途，共享同一套框架

---

## 3. GAS 概念映射

| GAS 概念 | 场景蓝图概念 | 说明 | 阶段 |
|----------|------------|------|------|
| GameplayAbility | **Action（行动）** | 一个可执行单元 | Phase 1 ✅ |
| GameplayTag | **Tag（标签）** | 层级化条件标签 | Phase 1 ✅ |
| GameplayEvent | **Event（事件）** | 通知/触发信号 | Phase 1 ✅ |
| AbilitySystemComponent | **BlueprintRunner** | 蓝图执行器 | Phase 1 ✅ |
| — | **Transition（过渡）** | 带条件的连线 | Phase 1 ✅ |
| — | **ActionDefinition** | 行动类型声明 | Phase 1 ✅ |
| — | **SceneBinding（场景绑定）** | 节点 ↔ 场景对象 | Phase 1 ✅ |
| AttributeSet | **Blackboard（黑板）** | 蓝图级共享变量 | ❌ 暂缓 |
| GameplayEffect | **Effect（效果）** | 对世界的持续修改 | ❌ 暂缓 |
| GameplayCue | **Cue（表现）** | 表现层反馈 | ❌ 暂缓 |
| AbilityTask | —（不需要） | NodeGraph 天然支持异步流程 | — |

### 3.1 为什么暂缓 Blackboard？

图的拓扑结构本身就是"程序"。Blackboard 本质上是给"没有图结构"的系统（如 GAS 的扁平 Ability 列表）提供状态传递能力。我们有图——节点间的连线和端口天然就是状态流动的通道。

替代方案：

| 替代机制 | 覆盖场景 |
|---------|---------|
| Action 多输出端口 | 行动自身的状态变化（onComplete / onFail / onHP50%） |
| Transition 条件 | 时间延迟、事件触发（Delay(3s) / Event("xxx")） |
| Flow 节点（Counter/Join/Branch） | 跨行动的聚合逻辑 |
| 蓝图级静态参数 | 全局配置（导出时确定，非运行时变量） |

如果将来确实遇到"必须在运行时跨行动共享动态状态"的场景，再引入 Blackboard——它是附加层，不影响已有机制。

---

## 4. 三层架构

```
┌─────────────────────────────────────────────────────────────────┐
│                                                                  │
│   Layer 3: Game-Specific Actions（游戏特定行动）                  │
│   ┌──────────┐ ┌──────────┐ ┌──────────┐ ┌──────────┐          │
│   │  Spawn   │ │   Trap   │ │  Camera  │ │  Light   │  ...     │
│   │  Action  │ │  Action  │ │  Action  │ │  Action  │          │
│   └────┬─────┘ └────┬─────┘ └────┬─────┘ └────┬─────┘          │
│        │ register    │            │             │                 │
│   ─────┼─────────────┼────────────┼─────────────┼─────────────   │
│        ▼             ▼            ▼             ▼                 │
│   Layer 2: SceneBlueprint SDK                                    │
│   ┌────────────────────────────────────────────────────────┐    │
│   │  ActionRegistry  ← ActionDefinition[]                   │    │
│   │  PropertySystem  ← PropertyDefinition[] + PropertyBag   │    │
│   │  TagSystem       ← hierarchical tags + conditions       │    │
│   │  Transition      ← condition expressions                │    │
│   │  BlueprintAsset  ← serialization                        │    │
│   │  BlueprintExporter ← 将图编译为运行时数据               │    │
│   │  InspectorGen    ← auto-generate property UI            │    │
│   └────────────────────────────────────────────────────────┘    │
│        │ depends on                                              │
│   ─────┼───────────────────────────────────────────────────────  │
│        ▼                                                         │
│   Layer 1: NodeGraph Framework                                   │
│   ┌────────────────────────────────────────────────────────┐    │
│   │  Graph / Node / Edge / Port                             │    │
│   │  Rendering (IMGUI 纯矢量)                               │    │
│   │  Layout / Interaction / Selection                        │    │
│   │  Serialization                                           │    │
│   └────────────────────────────────────────────────────────┘    │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

### 4.1 三方模型：Editor / Data / Runtime

核心约束：**编辑器和运行时不在同一个项目**。蓝图编辑器输出纯数据，运行时（帧同步引擎）消费数据。

```
┌─────────────────────────┐          ┌─────────────────────────┐
│   Unity Editor 项目      │          │   运行时项目             │
│   (当前工程)             │   导出    │   (帧同步引擎)           │
│                         │ ═══════► │                         │
│  · NodeGraph Framework  │  数据文件  │  · 帧同步逻辑            │
│  · SceneBlueprint SDK   │          │  · 战斗系统              │
│  · 可视化编辑器          │          │  · 怪物系统              │
│  · 不参与运行时          │          │  · 不知道 Unity          │
│                         │          │  · 不知道 NodeGraph      │
└─────────────────────────┘          └─────────────────────────┘
```

这意味着：
1. 蓝图的可视化图（节点/连线）是纯编辑器概念，运行时从来看不到
2. 运行时看到的是一份纯数据——行动列表 + 条件关系 + 属性参数
3. 运行时有自己的 ActionHandler 实现，和编辑器的 ActionDefinition 独立
4. 导出步骤是桥梁，负责把"图"编译成"数据"

---

## 5. 行动类型分类体系

按功能域分组：

```
┌─ Combat（战斗域）
│   ├─ PlacePreset    放置预设怪（瞬时，固定位置）
│   ├─ Spawn          节奏刷怪（持续，多波次）
│   ├─ PathSpawn      行进间刷怪（路径绑定）
│   ├─ BossPhase      Boss 阶段切换
│   ├─ Trap           陷阱激活/布置
│   ├─ Hazard         环境危害（毒雾、地刺）
│   └─ Buff           全局 Buff/Debuff
│
├─ Presentation（表现域）
│   ├─ Camera         摄像机控制（推拉摇移、震动、慢动作）
│   ├─ VFX            视觉特效
│   ├─ Audio          音频/音乐
│   └─ UI             UI 提示/文字
│
├─ Narrative（叙事域）
│   ├─ Dialogue       对话
│   ├─ Cutscene       过场动画
│   └─ Objective      任务目标提示
│
├─ Environment（环境域）
│   ├─ TerrainChange  地形变化（桥断裂、墙倒塌）
│   ├─ LightChange    光照变化
│   └─ Weather        天气变化
│
└─ Flow（流程域）← 蓝图内置
    ├─ Start          起点
    ├─ End            终点
    ├─ Delay          延迟
    ├─ Branch         条件分支
    ├─ Join           汇合
    ├─ Loop           循环
    ├─ Random         随机选择
    └─ SubBlueprint   子蓝图引用
```

### 5.1 Action 生命周期

```
Action 生命周期：
  Inactive → Activated → Running → Completed / Cancelled

Action 时间分类：
  瞬时行动 (Instant)  — 执行一次就完成（放置预设怪、切换灯光）
  持续行动 (Duration)  — 持续一段时间（节奏刷怪、摄像机跟踪、毒雾区域）
  被动行动 (Passive)   — 条件满足时自动响应（玩家进入区域时…）
```

### 5.2 与旧 SpawnTask 的对比

旧系统的 `SpawnTask` 是一个"巨型"对象，包含 12+ 个配置字段。新系统彻底拆解：

| 旧 SpawnTask 字段 | 新系统中谁承担 |
|-------------------|--------------|
| TriggerConfig | 图的连线 + Transition 条件 |
| DependsOn[] | 图的拓扑结构（连线天然表达依赖） |
| CompletionConfig | Action 输出端口 → 连到下一个节点 |
| MonsterGroupTemplate | SpawnAction 的 `template` 属性 |
| PlacementConfig | SpawnAction 的属性 + 场景绑定 |
| TempoConfig | SpawnAction 的 `tempo` 属性组 |
| ConstraintConfig | SpawnAction 的 `constraint` 属性组 |
| BehaviorOverride | SpawnAction 的属性（或独立 Modifier 节点） |

**Task 概念已废弃**——取而代之的是"图的拓扑 + Action 属性"的组合。

### 5.3 战斗域行动类型详情

| 行动类型 | 说明 | 权重 | 关键属性 | 输出端口 |
|---------|------|------|---------|---------|
| **PlacePreset** | 放置预设怪 | 轻 | template, sceneBinding | out |
| **Spawn** | 节奏刷怪 | 中 | template, tempo, area, constraints | out, onWaveComplete, onAllComplete |
| **PathSpawn** | 行进间刷怪 | 中 | template, path, triggerDistance | out, onPointTriggered, onAllComplete |
| **BossPhase** | Boss 阶段 | 重 | bossId, phase, hpThresholds | out, onHP*%（动态端口） |

---

## 6. 蓝图粒度

### 6.1 一个场景多张蓝图

每张蓝图 = 一个"遭遇"（Encounter），自包含，有自己的 Start 和结束。

```
地宫关卡场景
├─ 蓝图 A: "走廊伏击"        （行进间刷怪，~5 个节点）
├─ 蓝图 B: "房间A清场"       （一波刷怪，~3 个节点）
├─ 蓝图 C: "房间B遭遇战"     （多波 + 增援，~8 个节点）
├─ 蓝图 D: "Boss战"          （多阶段 + 增援 + 摄像机，~15 个节点）
└─ 蓝图 E: "逃脱序列"        （环境 + 追兵，~6 个节点）
```

每张蓝图推荐 **3~15 个节点**。

### 6.2 蓝图间衔接

蓝图之间不直接连线，衔接由游戏关卡逻辑管理：

```
关卡逻辑：
  玩家进入走廊 → 激活蓝图A
  蓝图A完成    → 开门 → 玩家进入房间A → 激活蓝图B
  蓝图B完成    → 开门 → Boss房 → 激活蓝图D
```

### 6.3 场景中的蓝图管理

```
SceneBlueprintManager (MonoBehaviour, 场景中唯一)
├─ BlueprintSlot "走廊伏击"
│   ├─ asset: corridor_ambush.json      ← 蓝图数据资产
│   ├─ trigger: "enter_corridor"         ← 何时激活
│   └─ sceneBindings:                    ← 场景绑定
│       ├─ "polygon_area_01" → SceneObject
│       └─ "path_01" → SceneObject
│
├─ BlueprintSlot "Boss战"
│   ├─ asset: boss_fight.json
│   ├─ trigger: "enter_boss_room"
│   └─ sceneBindings:
│       ├─ "spawn_area_boss" → SceneObject
│       └─ "camera_target" → SceneObject
│
└─ ...
```

### 6.4 多张 vs 一张大蓝图

| | 一张大蓝图 | 多张小蓝图 |
|---|---|---|
| **可读性** | 节点多时变蜘蛛网 | 每张图 3~15 节点，清晰 |
| **复用性** | 不可复用 | "走廊伏击"可用于多个走廊 |
| **协作** | 多人编辑同一文件易冲突 | 不同蓝图分给不同策划 |
| **测试** | 只能整关卡测试 | 可单独测试一个遭遇 |
| **运行时** | 整关卡一次性加载 | 按需加载/卸载 |

---

## 7. 编排模式示例

### 7.1 基础：顺序执行

```
[Start] → [Spawn "第1波"] → [Spawn "第2波"] → [End]
```

### 7.2 预设怪 + 触发刷怪

```
[Start] ─────────────→ [PlacePreset "巡逻精英"]
   │
   │  Event("enter_boss_room")
   └──────────────────→ [Spawn "小怪第1波"] ──onAllComplete──→ [BossPhase 1]
```

### 7.3 增援（不等打完）

```
[Start] → [Spawn "主力" waves:3]
               │
               │ onWaveComplete ──Delay(5s)──→ [Spawn "增援" "从侧翼包抄"]
               │
               │ onAllComplete ──→ ...
```

### 7.4 Boss 战多阶段

```
[Start] → [Spawn "前哨"] ──onAllComplete──→ [BossPhase 1 boss:魔王]
                                                │ onHP50% → [Spawn "增援1"]
                                                │ onHP20% → [BossPhase 2 "狂暴"]
```

### 7.5 行进间刷怪

**方式 A：多触发点 + 多 Spawn**

```
[Start] ─Event("reach_point_1")─→ [Spawn "伏兵1"]
   │    ─Event("reach_point_2")─→ [Spawn "伏兵2"]
   │    ─Event("reach_point_3")─→ [Spawn "伏兵3"]
```

**方式 B：PathSpawn 封装**

```
[Start] ─Event("enter_corridor")─→ [PathSpawn path:"corridor_01" triggerDist:15m]
```

### 7.6 编排模式总结

| 编排模式 | 图表达方式 |
|---------|-----------|
| 顺序执行 | A → B → C（线性连接） |
| 并行执行 | A 同时连到 B 和 C（分叉） |
| 增援/追加 | A.onWaveComplete → B（中间端口分叉） |
| 条件分支 | A.onHP50% → B，A.onHP20% → C（多输出端口） |
| 延迟触发 | A → Delay(5s) → B |
| 事件触发 | Start → Event("xxx") → B（连线条件） |
| 循环刷怪 | A.onAllComplete → Delay(10s) → A（回环连线） |

---

## 8. 技术依赖

| 层级 | 依赖 |
|------|------|
| SceneBlueprint SDK | NodeGraph Framework（Core / View / Commands / Serialization） |
| Game Actions（Layer 3） | SceneBlueprint SDK + 游戏业务层 |
| 运行时 | 仅依赖导出的数据格式（JSON），不依赖 Unity / NodeGraph |

---

## 9. 实施路线（概览）

| 阶段 | 内容 | 依赖 |
|------|------|------|
| **Phase 1** | ActionDefinition + ActionRegistry + PropertySystem | NodeGraph Framework |
| **Phase 2** | 蓝图编辑器窗口（替代旧 SpawnBlueprintWindow） | Phase 1 |
| **Phase 3** | 数据导出（BlueprintExporter → SceneBlueprintData） | Phase 1 |
| **Phase 4** | 场景绑定（SceneBinding + SceneBlueprintManager） | Phase 2 + 3 |
| **Phase 5** | Tag 系统集成 | Phase 1 |
| **Phase 6** | AI Director（基础） | Phase 3（运行时侧） |
| **Phase 7** | AI Director（完整 Utility AI） | Phase 6 |

详细实施计划见各子系统设计文档。

---

## 10. 相关文档

| 文档 | 内容 |
|------|------|
| [Action与属性系统设计](Action与属性系统设计.md) | ActionDefinition、ActionRegistry、PropertyDefinition、Inspector 自动生成 |
| [数据导出与运行时契约](数据导出与运行时契约.md) | SceneBlueprintData 格式、导出流程、运行时 Handler 接口 |
| [AI Director设计](AI%20Director设计.md) | Utility AI、CombatPerception、情绪曲线、directorInfluence |

### 历史文档（旧刷怪系统，仅供参考）

位于 `Assets/Extensions/CombatBlueprint/Documents/`：
- ARPG怪物生成机制研究.md
- 自动战斗刷怪系统设计指南.md
- 怪物Tag体系设计.md
- 双层设计框架与预设编辑器集成.md
- 移除Recipe层优化方案.md
- 场景优先工作流设计.md
- 战斗蓝图编辑器设计文档.md
