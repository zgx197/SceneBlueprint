# 数据导出与运行时契约

> 版本：v1.0  
> 日期：2026-02-12  
> 状态：设计阶段  
> 父文档：[场景蓝图系统总体设计](场景蓝图系统总体设计.md)

---

## 1. 概述

本文档定义编辑器和运行时之间的**唯一契约**——导出数据格式 `SceneBlueprintData`。

核心约束：
- **零代码依赖**：数据层不引用 Unity、NodeGraph、SceneBlueprint SDK
- **可序列化**：JSON 格式（开发期），可选二进制（发布期）
- **自描述**：运行时不需要 ActionDefinition 就能理解数据结构
- **编辑器输出，运行时消费**：两方通过字符串约定（TypeId、PropertyKey）对齐

---

## 2. 数据模型

### 2.1 SceneBlueprintData（顶层）

```csharp
// 纯数据类，无任何框架依赖
public class SceneBlueprintData
{
    // ─── 元信息 ───
    public string BlueprintId;      // 蓝图唯一 ID
    public string BlueprintName;    // 蓝图名称
    public int Version;             // 数据版本号
    public string ExportTime;       // 导出时间戳

    // ─── 核心数据 ───
    public ActionEntry[] Actions;           // 行动表
    public TransitionEntry[] Transitions;   // 过渡表
    public VariableEntry[] BlackboardInit;  // 黑板初始值（Phase 2+，当前为空）
}
```

### 2.2 ActionEntry（行动条目）

```csharp
public class ActionEntry
{
    public string Id;               // 行动唯一 ID（来自图中节点 ID）
    public string TypeId;           // 行动类型，如 "Combat.Spawn", "Flow.Start"

    // 属性——扁平化键值对
    public PropertyValue[] Properties;

    // 场景绑定（可选）
    public SceneBindingEntry[] SceneBindings;
}
```

### 2.3 PropertyValue（属性值）

```csharp
public class PropertyValue
{
    public string Key;              // 属性键名，如 "template", "interval"
    public string ValueType;        // 值类型标识，如 "float", "int", "string", "assetRef"
    public string Value;            // 序列化后的值（字符串形式）
}
```

**为什么用 `string Value` 而不是类型化字段？**

1. 数据域不知道也不需要知道具体属性的语义——"interval" 到底是刷怪间隔还是灯光渐变时间，数据域不关心
2. 编辑器根据 PropertyDefinition 知道如何序列化/反序列化
3. 运行时根据 TypeId 知道如何解读属性——`ActionHandler["Combat.Spawn"]` 知道 "interval" 是 float
4. 字符串在 JSON 中天然友好，未来换二进制格式时加一层编码即可

### 2.4 TransitionEntry（过渡条目）

```csharp
public class TransitionEntry
{
    public string FromActionId;     // 来源行动 ID
    public string FromPortId;       // 来源端口，如 "out", "onComplete", "true"
    public string ToActionId;       // 目标行动 ID
    public string ToPortId;         // 目标端口，如 "in"

    // 条件（可组合）
    public ConditionData Condition;
}
```

### 2.5 ConditionData（条件数据）

```csharp
public class ConditionData
{
    public string Type;             // 条件类型：
                                    //   "Immediate"  — 立即触发
                                    //   "Delay"      — 延迟
                                    //   "Expression" — 表达式
                                    //   "Tag"        — 标签匹配
                                    //   "Event"      — 事件触发
                                    //   "AllOf"      — 全部满足（AND）
                                    //   "AnyOf"      — 任一满足（OR）

    public string Expression;       // 条件表达式：
                                    //   Delay:      "3.0"（秒数）
                                    //   Expression: "bossHP < 0.5"
                                    //   Tag:        "Combat.Phase.2"
                                    //   Event:      "player_enter_area"

    public ConditionData[] Children;// 组合条件的子条件（AllOf/AnyOf 时使用）
}
```

### 2.6 SceneBindingEntry（场景绑定条目）

```csharp
public class SceneBindingEntry
{
    public string BindingKey;       // 绑定键名，如 "spawnArea", "triggerArea", "targetLight"
    public string BindingType;      // 绑定类型，如 "Transform", "Area", "Path", "Collider"
    public string SceneObjectId;    // 场景对象标识（名字/路径/自定义 ID）
}
```

### 2.7 VariableEntry（变量条目，Phase 2+）

```csharp
public class VariableEntry
{
    public string Key;              // 变量名
    public string ValueType;        // "float", "int", "bool", "string"
    public string InitialValue;     // 初始值
}
```

---

## 3. 导出流程

```
编辑器中的蓝图（Graph）
    │
    │ BlueprintExporter.Export(graph, registry)
    │
    │ 步骤 1: 遍历所有节点
    │   Node → ActionEntry
    │   ActionNodeData.Properties → PropertyValue[]
    │   （根据 PropertyDefinition.Type 决定序列化方式）
    │
    │ 步骤 2: 遍历所有连线
    │   Edge → TransitionEntry
    │   EdgeData.Condition → ConditionData
    │
    │ 步骤 3: 收集场景绑定
    │   PropertyType.SceneBinding 的属性 → SceneBindingEntry[]
    │   （将 Unity 场景引用转为可序列化的字符串标识）
    │
    │ 步骤 4: 验证
    │   · 检查孤立节点（无连入也无连出）
    │   · 检查必填属性缺失
    │   · 检查循环依赖（可选，图允许有向环用于循环刷怪）
    │   · 检查类型一致性（端口连接是否合法）
    │
    │ 步骤 5: 序列化
    │   SceneBlueprintData → JSON string
    │
    ▼
SceneBlueprintData (JSON)
    │
    │ 保存到文件
    ▼
Assets/ExportedData/SceneBlueprints/{blueprintId}.json
```

### 3.1 属性序列化规则

| PropertyType | ValueType 字符串 | Value 序列化方式 |
|-------------|-----------------|----------------|
| Float | `"float"` | `"2.5"` |
| Int | `"int"` | `"5"` |
| Bool | `"bool"` | `"true"` / `"false"` |
| String | `"string"` | 原始字符串 |
| Enum | `"enum"` | 枚举名字符串 `"Interval"` |
| AssetRef | `"assetRef"` | 资产标识字符串（如模板 ID `"elite_group_01"`） |
| Vector2 | `"vector2"` | `"1.5,2.0"` |
| Vector3 | `"vector3"` | `"1.5,2.0,3.0"` |
| Color | `"color"` | `"1.0,0.5,0.0,1.0"` (RGBA) |
| Tag | `"tag"` | Tag 路径 `"Combat.Phase.2"` |
| SceneBinding | — | 提升为 SceneBindingEntry，不在 Properties 中 |

### 3.2 AssetRef 特殊处理

编辑器中 AssetRef 存的是 Unity Object 引用（GUID）。导出时需要转换为运行时可识别的字符串标识：

```
编辑器中：MonsterGroupTemplate (UnityEngine.Object, GUID: abc123)
    ↓ 导出转换
运行时数据：{ Key: "template", ValueType: "assetRef", Value: "elite_group_01" }
```

转换策略由 `IAssetIdResolver` 接口定义：

```csharp
public interface IAssetIdResolver
{
    /// <summary>将 Unity 资产引用转换为运行时标识字符串</summary>
    string Resolve(UnityEngine.Object asset);
}
```

不同项目可以有不同的实现（用资产名、用配置表 ID、用路径等）。

---

## 4. 导出示例

### 4.1 简单的 Boss 战蓝图

```json
{
  "BlueprintId": "boss_room_01",
  "BlueprintName": "Boss房间战斗编排",
  "Version": 1,
  "ExportTime": "2026-02-12T10:30:00Z",
  "Actions": [
    {
      "Id": "start_1",
      "TypeId": "Flow.Start",
      "Properties": [],
      "SceneBindings": []
    },
    {
      "Id": "spawn_1",
      "TypeId": "Combat.Spawn",
      "Properties": [
        { "Key": "template", "ValueType": "assetRef", "Value": "elite_group_01" },
        { "Key": "tempoType", "ValueType": "enum", "Value": "Interval" },
        { "Key": "interval", "ValueType": "float", "Value": "2.0" },
        { "Key": "totalWaves", "ValueType": "int", "Value": "3" },
        { "Key": "monstersPerWave", "ValueType": "int", "Value": "5" }
      ],
      "SceneBindings": [
        { "BindingKey": "spawnArea", "BindingType": "Area", "SceneObjectId": "spawn_area_01" }
      ]
    },
    {
      "Id": "camera_1",
      "TypeId": "Presentation.Camera",
      "Properties": [
        { "Key": "action", "ValueType": "enum", "Value": "ZoomIn" },
        { "Key": "duration", "ValueType": "float", "Value": "1.5" }
      ],
      "SceneBindings": []
    },
    {
      "Id": "boss_phase1",
      "TypeId": "Combat.BossPhase",
      "Properties": [
        { "Key": "bossId", "ValueType": "assetRef", "Value": "boss_demon_king" },
        { "Key": "phase", "ValueType": "int", "Value": "1" }
      ],
      "SceneBindings": []
    }
  ],
  "Transitions": [
    {
      "FromActionId": "start_1",
      "FromPortId": "out",
      "ToActionId": "spawn_1",
      "ToPortId": "in",
      "Condition": { "Type": "Immediate", "Expression": null, "Children": null }
    },
    {
      "FromActionId": "spawn_1",
      "FromPortId": "onAllComplete",
      "ToActionId": "camera_1",
      "ToPortId": "in",
      "Condition": { "Type": "Immediate", "Expression": null, "Children": null }
    },
    {
      "FromActionId": "camera_1",
      "FromPortId": "out",
      "ToActionId": "boss_phase1",
      "ToPortId": "in",
      "Condition": { "Type": "Delay", "Expression": "2.0", "Children": null }
    }
  ],
  "BlackboardInit": []
}
```

### 4.2 带增援和事件触发的蓝图

```json
{
  "BlueprintId": "corridor_ambush",
  "BlueprintName": "走廊伏击",
  "Version": 1,
  "Actions": [
    { "Id": "start", "TypeId": "Flow.Start", "Properties": [] },
    {
      "Id": "spawn_main",
      "TypeId": "Combat.Spawn",
      "Properties": [
        { "Key": "template", "ValueType": "assetRef", "Value": "normal_group" },
        { "Key": "tempoType", "ValueType": "enum", "Value": "Interval" },
        { "Key": "interval", "ValueType": "float", "Value": "2.0" },
        { "Key": "totalWaves", "ValueType": "int", "Value": "3" },
        { "Key": "monstersPerWave", "ValueType": "int", "Value": "5" }
      ],
      "SceneBindings": [
        { "BindingKey": "spawnArea", "BindingType": "Area", "SceneObjectId": "corridor_area_01" }
      ]
    },
    {
      "Id": "spawn_flank",
      "TypeId": "Combat.Spawn",
      "Properties": [
        { "Key": "template", "ValueType": "assetRef", "Value": "elite_group" },
        { "Key": "tempoType", "ValueType": "enum", "Value": "Instant" },
        { "Key": "monstersPerWave", "ValueType": "int", "Value": "3" }
      ],
      "SceneBindings": [
        { "BindingKey": "spawnArea", "BindingType": "Area", "SceneObjectId": "flank_area_01" }
      ]
    }
  ],
  "Transitions": [
    {
      "FromActionId": "start", "FromPortId": "out",
      "ToActionId": "spawn_main", "ToPortId": "in",
      "Condition": { "Type": "Event", "Expression": "enter_corridor" }
    },
    {
      "FromActionId": "spawn_main", "FromPortId": "onWaveComplete",
      "ToActionId": "spawn_flank", "ToPortId": "in",
      "Condition": { "Type": "Delay", "Expression": "5.0" }
    }
  ]
}
```

---

## 5. 运行时侧职责

运行时**不依赖** Unity / NodeGraph / SceneBlueprint SDK，只需要：

### 5.1 数据加载

```
1. 读取 SceneBlueprintData（JSON 反序列化）
2. 构建行动表和过渡表的索引结构
```

### 5.2 行动处理器注册

```csharp
// 运行时 ActionHandler 映射
Dictionary<string, IActionHandler> handlers = new()
{
    ["Flow.Start"]        = new StartHandler(),
    ["Flow.End"]          = new EndHandler(),
    ["Flow.Delay"]        = new DelayHandler(),
    ["Combat.Spawn"]      = new SpawnHandler(),
    ["Combat.PlacePreset"] = new PlacePresetHandler(),
    ["Combat.BossPhase"]  = new BossPhaseHandler(),
    ["Presentation.Camera"] = new CameraHandler(),
    // ...
};

public interface IActionHandler
{
    void Activate(ActionEntry action, Blackboard blackboard);
    ActionStatus Tick(ActionEntry action, float deltaTime);
    void Cancel(ActionEntry action);
}
```

### 5.3 执行循环

```
BlueprintRunner 执行循环：
  1. 从 "Flow.Start" 行动开始
  2. 激活行动 → 调用对应 Handler.Activate()
  3. 每帧 Tick 活跃行动 → Handler.Tick() → 返回 Running / Completed / Failed
  4. 行动完成时，评估所有从该行动出发的 Transition
  5. Transition 条件满足 → 激活目标行动
  6. 所有行动完成（或到达 Flow.End） → 蓝图执行完毕
```

### 5.4 编辑器与运行时的唯一契约

| 契约项 | 说明 |
|-------|------|
| **TypeId 字符串** | 两边一致（"Combat.Spawn"） |
| **Property Key 字符串** | 两边一致（"interval"、"template"） |
| **ConditionData 格式** | 两边一致 |
| **SceneObjectId** | 两边一致（场景中的标识方式） |
| **AssetRef 标识** | 两边一致（资产名/配置表 ID） |

---

## 6. 数据格式选择

| 方案 | 说明 | 适用阶段 |
|------|------|---------|
| **JSON** | 人类可读，调试方便，Unity JsonUtility 或 Newtonsoft 支持 | 开发期（默认） |
| **FlatBuffers / Protobuf** | 二进制，解析快，体积小 | 发布期（可选） |
| **JSON 编辑 + Binary 发布** | 编辑器导出 JSON，发布时压缩为二进制 | 推荐的最终方案 |

Phase 1 使用 JSON，后续按需引入二进制格式。

---

## 7. 场景绑定跨项目传递

### 7.1 问题

编辑器中通过 Unity 场景对象引用（GameObject、Transform）建立绑定。导出后运行时如何找到对应的场景对象？

### 7.2 方案：混合策略

| 数据类型 | 导出方式 | 运行时查找 |
|---------|---------|-----------|
| **位置类**（坐标、区域顶点、路径点） | 直接导出数值 | 不需要查找，数据自包含 |
| **引用类**（目标灯光、摄像机目标） | 导出字符串 ID | 运行时场景中预先放好同名标记对象 |

```json
// 位置类：直接导出数值
{
  "BindingKey": "spawnArea",
  "BindingType": "Area",
  "SceneObjectId": "polygon_area_01",
  "ExportedData": {
    "vertices": [[1.0, 0.0, 2.0], [3.0, 0.0, 2.0], [3.0, 0.0, 5.0], [1.0, 0.0, 5.0]]
  }
}

// 引用类：用 ID 映射
{
  "BindingKey": "targetLight",
  "BindingType": "Transform",
  "SceneObjectId": "boss_room_spotlight_01"
}
```

---

## 8. 验证规则

BlueprintExporter 导出前执行的校验：

| 规则 | 级别 | 说明 |
|------|------|------|
| 必须有且仅有一个 Flow.Start | Error | 蓝图入口唯一 |
| 所有必填属性不为空 | Error | 根据 PropertyDefinition 检查 |
| 孤立节点警告 | Warning | 无连入也无连出的节点 |
| SceneBinding 引用存在 | Warning | 绑定的场景对象是否在场景中 |
| TypeId 已注册 | Error | ActionRegistry 中存在对应定义 |
| 端口连接合法 | Error | Out 端口连到 In 端口 |

---

## 9. 版本兼容

数据中包含 `Version` 字段，用于运行时兼容性检查：

```
Version 1: 初始版本
Version 2+: 如有字段新增/变更，运行时需要迁移逻辑
```

新增字段用可空/默认值保证向后兼容，删除字段用 Version 号区分。

---

## 10. 实施步骤

| 步骤 | 内容 | 估时 |
|------|------|------|
| 1 | 定义纯数据类（SceneBlueprintData 全家族） | 0.5d |
| 2 | 实现 BlueprintExporter（Graph → SceneBlueprintData） | 1d |
| 3 | 实现 JSON 序列化/反序列化 | 0.5d |
| 4 | 实现 IAssetIdResolver 接口及默认实现 | 0.5d |
| 5 | 实现导出验证规则 | 0.5d |
| 6 | 编辑器 UI 集成（导出按钮、验证结果显示） | 0.5d |
| 7 | 场景绑定导出（位置类直接导出 + 引用类 ID 映射） | 1d |

---

## 11. 相关文档

- [场景蓝图系统总体设计](场景蓝图系统总体设计.md)
- [Action与属性系统设计](Action与属性系统设计.md)
- [AI Director设计](AI%20Director设计.md)
