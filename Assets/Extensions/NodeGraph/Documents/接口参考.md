# NodeGraph 接口参考

> 本文档是 NodeGraph 框架关键接口的快速参考，详细设计请参阅《NodeGraph设计文档.md》。

---

## 1. 核心接口

### INodeData / IEdgeData

业务层数据的标记接口，由业务层实现。

```csharp
public interface INodeData { }
public interface IEdgeData { }
```

---

### IConnectionPolicy

连接策略接口，决定两个端口能否连线。

```csharp
public interface IConnectionPolicy
{
    ConnectionResult CanConnect(Graph graph, Port source, Port target);
}
```

**内置实现**：`DefaultConnectionPolicy`（基本规则 + DAG 环检测）

**业务层扩展示例**：

```csharp
public class MyConnectionPolicy : DefaultConnectionPolicy
{
    public override ConnectionResult CanConnect(Graph graph, Port source, Port target)
    {
        var result = base.CanConnect(graph, source, target);
        if (result != ConnectionResult.Success) return result;
        
        // 自定义规则
        return ConnectionResult.Success;
    }
}
```

---

## 2. 渲染接口

### IDrawContext

2D 图元绘制接口，每个引擎必须实现。

```csharp
public interface IDrawContext
{
    // 矩形
    void DrawRect(Rect2 rect, Color4 fill);
    void DrawRectOutline(Rect2 rect, Color4 color, float width);
    void DrawRoundedRect(Rect2 rect, float radius, Color4 fill);
    void DrawRoundedRectOutline(Rect2 rect, float radius, Color4 color, float width);
    
    // 圆形
    void DrawCircle(Vec2 center, float radius, Color4 fill);
    void DrawCircleOutline(Vec2 center, float radius, Color4 color, float width);
    
    // 线条
    void DrawLine(Vec2 from, Vec2 to, Color4 color, float width);
    void DrawBezier(Vec2 start, Vec2 end, Vec2 tangentA, Vec2 tangentB,
                    Color4 color, float width);
    
    // 文字
    void DrawText(string text, Vec2 position, float fontSize, Color4 color,
                  TextAlign align = TextAlign.Left);
    Vec2 MeasureText(string text, float fontSize);
    
    // 图标（默认空实现）
    void DrawIcon(string iconId, Vec2 position, Vec2 size, Color4 tint) { }
    
    // 裁剪与变换
    void PushClipRect(Rect2 rect);
    void PopClipRect();
    void PushTransform(Vec2 translate, float scale);
    void PopTransform();
    
    // 复合绘制（有默认实现，可覆盖优化）
    void DrawGrid(Rect2 viewport, float gridSize, Color4 lineColor, Color4 bgColor) { ... }
    void DrawArrow(Vec2 from, Vec2 to, Color4 color, float width, float arrowSize) { ... }
}
```

---

### IEditContext

IMGUI 风格的编辑控件接口，用于节点内嵌编辑。

```csharp
public interface IEditContext
{
    // 基础控件（传入当前值，返回修改后的值）
    float FloatField(string label, float value);
    int IntField(string label, int value);
    string TextField(string label, string value);
    bool Toggle(string label, bool value);
    float Slider(string label, float value, float min, float max);
    int Popup(string label, int selectedIndex, string[] options);
    Color4 ColorField(string label, Color4 value);
    
    // 布局
    void Label(string text);
    void Space(float pixels);
    void BeginHorizontal();
    void EndHorizontal();
    bool Foldout(string label, bool expanded);
    void Separator();
    
    // 状态
    bool HasChanged { get; }
    Rect2 AvailableRect { get; }
}
```

**各引擎映射**：

| 方法 | Unity | Godot 4 | Dear ImGui |
|------|-------|---------|------------|
| `FloatField` | `EditorGUI.FloatField` | SpinBox 控件池 | `ImGui.DragFloat` |
| `TextField` | `EditorGUI.TextField` | LineEdit 控件池 | `ImGui.InputText` |
| `Toggle` | `EditorGUI.Toggle` | CheckBox 控件池 | `ImGui.Checkbox` |
| `Popup` | `EditorGUI.Popup` | OptionButton 控件池 | `ImGui.Combo` |
| `Slider` | `EditorGUI.Slider` | HSlider 控件池 | `ImGui.SliderFloat` |

---

### IPlatformInput

平台输入抽象接口。

```csharp
public interface IPlatformInput
{
    Vec2 MousePosition { get; }
    Vec2 MouseDelta { get; }
    float ScrollDelta { get; }
    
    bool IsMouseDown(MouseButton button);
    bool IsMouseUp(MouseButton button);
    bool IsMouseDrag(MouseButton button);
    bool IsDoubleClick(MouseButton button);
    
    bool IsKeyDown(string keyName);
    bool IsKeyHeld(string keyName);
    
    bool IsShiftHeld { get; }
    bool IsCtrlHeld { get; }
    bool IsAltHeld { get; }
    
    string GetClipboardText();
    void SetClipboardText(string text);
}
```

---

## 3. 扩展接口

### INodeContentRenderer

节点内容渲染接口，业务层为每种节点类型实现。

```csharp
public interface INodeContentRenderer
{
    /// <summary>是否支持内嵌编辑</summary>
    bool SupportsInlineEdit { get; }
    
    // 摘要视图（只读，使用 IDrawContext）
    Vec2 GetSummarySize(Node node, IDrawContext ctx);
    void DrawSummary(Node node, Rect2 rect, IDrawContext ctx);
    
    // 折叠模式一行摘要
    string GetOneLiner(Node node);
    
    // 编辑视图（可交互，使用 IEditContext）
    Vec2 GetEditorSize(Node node, IEditContext ctx);
    void DrawEditor(Node node, Rect2 rect, IEditContext ctx);
}
```

**使用示例（刷怪蓝图）**：

```csharp
public class SpawnTaskContentRenderer : INodeContentRenderer
{
    public bool SupportsInlineEdit => true;
    
    public Vec2 GetSummarySize(Node node, IDrawContext ctx)
    {
        return new Vec2(180, 60);
    }
    
    public void DrawSummary(Node node, Rect2 rect, IDrawContext ctx)
    {
        var data = (SpawnTaskData)node.UserData!;
        ctx.DrawText($"怪物: {data.TemplateName}", rect.TopLeft, 12, Color4.White);
        ctx.DrawText($"波次: {data.WaveCount}  间隔: {data.Interval}s",
            rect.TopLeft + new Vec2(0, 18), 11, Color4.White.WithAlpha(0.7f));
        ctx.DrawText($"约束: 最大{data.MaxAlive}只",
            rect.TopLeft + new Vec2(0, 36), 11, Color4.White.WithAlpha(0.7f));
    }
    
    public string GetOneLiner(Node node)
    {
        var data = (SpawnTaskData)node.UserData!;
        return $"{data.TemplateName} / {data.WaveCount}波";
    }
    
    public Vec2 GetEditorSize(Node node, IEditContext ctx) => new Vec2(200, 120);
    
    public void DrawEditor(Node node, Rect2 rect, IEditContext ctx)
    {
        var data = (SpawnTaskData)node.UserData!;
        data.WaveCount = ctx.IntField("波次", data.WaveCount);
        data.Interval = ctx.FloatField("间隔(s)", data.Interval);
        data.MaxAlive = ctx.IntField("最大存活", data.MaxAlive);
        
        if (ctx.HasChanged)
            node.State = NodeState.Normal; // 清除错误状态
    }
}
```

---

### IEdgeLabelRenderer

连线标签渲染接口，可选实现。

```csharp
public interface IEdgeLabelRenderer
{
    Vec2 GetLabelSize(Edge edge, IDrawContext ctx);
    void DrawLabel(Edge edge, Vec2 midpoint, IDrawContext ctx);
    bool HandleLabelClick(Edge edge, Rect2 labelRect);
}
```

**使用示例（刷怪蓝图 Transition 标签）**：

```csharp
public class TransitionLabelRenderer : IEdgeLabelRenderer
{
    public Vec2 GetLabelSize(Edge edge, IDrawContext ctx)
    {
        var text = GetLabelText(edge);
        var size = ctx.MeasureText(text, 10);
        return size + new Vec2(12, 6); // padding
    }
    
    public void DrawLabel(Edge edge, Vec2 midpoint, IDrawContext ctx)
    {
        var text = GetLabelText(edge);
        var size = GetLabelSize(edge, ctx);
        var rect = new Rect2(midpoint.X - size.X / 2, midpoint.Y - size.Y / 2,
                             size.X, size.Y);
        
        ctx.DrawRoundedRect(rect, 4, Color4.FromHex("#2D2D2D"));
        ctx.DrawRoundedRectOutline(rect, 4, Color4.FromHex("#555555"), 1);
        ctx.DrawText(text, midpoint, 10, Color4.White, TextAlign.Center);
    }
    
    private string GetLabelText(Edge edge)
    {
        if (edge.UserData is TransitionConditionData tc)
        {
            return tc.Type switch
            {
                TransitionType.Immediate => "立即",
                TransitionType.AllKilled => "全灭",
                TransitionType.Delay => $"延迟 {tc.DelaySeconds}s",
                TransitionType.PercentKilled => $"击杀 {tc.KillPercent:P0}",
                _ => tc.Type.ToString()
            };
        }
        return "";
    }
}
```

---

### IGraphValidator

图验证接口，业务层可实现自定义验证规则。

```csharp
public interface IGraphValidator
{
    /// <summary>验证整个图的合法性</summary>
    IEnumerable<ValidationMessage> Validate(Graph graph);
}

public class ValidationMessage
{
    public ValidationSeverity Severity { get; }   // Error / Warning / Info
    public string Message { get; }
    public string? NodeId { get; }                 // 关联的节点（可选）
    public string? EdgeId { get; }                 // 关联的连线（可选）
}

public enum ValidationSeverity { Info, Warning, Error }
```

**使用示例**：

```csharp
public class SpawnPlanValidator : IGraphValidator
{
    public IEnumerable<ValidationMessage> Validate(Graph graph)
    {
        // 检查是否有根节点
        var roots = GraphAlgorithms.GetRootNodes(graph).ToList();
        if (roots.Count == 0)
            yield return new ValidationMessage(Error, "Plan 没有入口节点");
        
        // 检查是否所有节点都可达
        if (roots.Count > 0)
        {
            var reachable = GraphAlgorithms.GetReachableNodes(graph, roots[0].Id);
            foreach (var node in graph.Nodes)
            {
                if (!reachable.Contains(node.Id))
                    yield return new ValidationMessage(Warning,
                        $"节点 '{node.TypeId}' 不可达", node.Id);
            }
        }
        
        // 检查每个 SpawnTask 是否配置了怪物模板
        foreach (var node in graph.Nodes.Where(n => n.TypeId == "SpawnTask"))
        {
            var data = node.UserData as SpawnTaskData;
            if (data == null || string.IsNullOrEmpty(data.TemplateName))
                yield return new ValidationMessage(Error,
                    "刷怪任务未配置怪物模板", node.Id);
        }
    }
}
```

---

### IUserDataSerializer

业务数据的 JSON 序列化接口。

```csharp
public interface IUserDataSerializer
{
    string SerializeNodeData(INodeData data);
    INodeData? DeserializeNodeData(string typeId, string json);
    string SerializeEdgeData(IEdgeData data);
    IEdgeData? DeserializeEdgeData(string json);
}
```

---

## 4. 接入新引擎的最小实现清单

| 接口 | 必须实现 | 方法数 |
|------|---------|--------|
| `IDrawContext` | ✅ | ~15 个（含默认实现约 10 个必须） |
| `IEditContext` | ✅（如需内嵌编辑） | ~12 个 |
| `IPlatformInput` | ✅ | ~12 个 |
| 宿主窗口 | ✅ | 1 个类 |

**最小可运行实现**：约 4 个类，300-500 行代码。
