# NodeGraph 框架测试指南

> **版本**: v1.0  
> **日期**: 2026-02-10

---

## 1. 编译验证

确保 Unity 编辑器无 NodeGraph 相关编译错误：

1. 打开 Unity 项目
2. 等待编译完成
3. 确认 Console 窗口无 `NodeGraph.*` 命名空间的编译错误

> **注意**：`StageDesigner` 模块的编译错误（如 `Config` 命名空间缺失）是该模块自身的问题，与 NodeGraph 框架无关。

---

## 2. 基础框架测试（纯代码）

在 Unity 中创建一个临时测试脚本，放在 `Editor/` 目录下：

```csharp
using UnityEngine;
using UnityEditor;
using NodeGraph.Core;
using NodeGraph.Math;
using NodeGraph.Commands;
using NodeGraph.Layout;
using NodeGraph.Serialization;

public static class NodeGraphQuickTest
{
    [MenuItem("Tools/NodeGraph/运行快速测试")]
    public static void RunTest()
    {
        Debug.Log("=== NodeGraph 快速测试开始 ===");

        // ── 1. 数学类型 ──
        var v1 = new Vec2(3, 4);
        Debug.Assert(Mathf.Approximately(v1.Length(), 5f), "Vec2.Length 失败");
        var c = Color4.FromHex("#FF0000");
        Debug.Assert(c.R > 0.99f && c.G < 0.01f, "Color4.FromHex 失败");
        Debug.Log("✓ Math 模块正常");

        // ── 2. 图创建 + 节点/连线 ──
        var settings = new GraphSettings { Topology = GraphTopologyPolicy.DAG };
        var graph = new Graph(settings);
        Debug.Assert(graph.Nodes.Count == 0, "初始节点数应为0");

        var registry = settings.NodeTypes;
        registry.Register(new NodeTypeDefinition("Test", "测试节点", "测试",
            new[] {
                new PortDefinition("In", PortDirection.Input),
                new PortDefinition("Out", PortDirection.Output)
            }));

        var nodeA = new Node(IdGenerator.NewId(), "Test", new Vec2(100, 100));
        var portAIn = new Port(IdGenerator.NewId(), nodeA.Id,
            registry.GetDefinition("Test").DefaultPorts[0]);
        var portAOut = new Port(IdGenerator.NewId(), nodeA.Id,
            registry.GetDefinition("Test").DefaultPorts[1]);
        nodeA.AddPortDirect(portAIn);
        nodeA.AddPortDirect(portAOut);
        graph.AddNodeDirect(nodeA);

        var nodeB = new Node(IdGenerator.NewId(), "Test", new Vec2(300, 100));
        var portBIn = new Port(IdGenerator.NewId(), nodeB.Id,
            registry.GetDefinition("Test").DefaultPorts[0]);
        var portBOut = new Port(IdGenerator.NewId(), nodeB.Id,
            registry.GetDefinition("Test").DefaultPorts[1]);
        nodeB.AddPortDirect(portBIn);
        nodeB.AddPortDirect(portBOut);
        graph.AddNodeDirect(nodeB);

        Debug.Assert(graph.Nodes.Count == 2, "节点数应为2");

        var edge = new Edge(IdGenerator.NewId(), portAOut.Id, portBIn.Id);
        graph.AddEdgeDirect(edge);
        Debug.Assert(graph.Edges.Count == 1, "连线数应为1");
        Debug.Log("✓ Core 模块（Graph/Node/Port/Edge）正常");

        // ── 3. 命令系统 ──
        var history = new CommandHistory(graph);
        Debug.Assert(history.UndoCount == 0, "初始 Undo 栈应为空");
        Debug.Log("✓ Commands 模块正常");

        // ── 4. 图算法 ──
        var roots = GraphAlgorithms.GetRootNodes(graph);
        Debug.Assert(System.Linq.Enumerable.Count(roots) >= 1, "应至少有1个根节点");

        var sorted = GraphAlgorithms.TopologicalSort(graph);
        Debug.Assert(sorted != null, "DAG 应能拓扑排序");
        Debug.Assert(sorted.Count == 2, "拓扑排序应包含2个节点");
        Debug.Log("✓ GraphAlgorithms 正常");

        // ── 5. 布局算法 ──
        var treeLayout = new TreeLayout();
        var positions = treeLayout.ComputeLayout(graph, Vec2.Zero);
        Debug.Assert(positions.Count == 2, "布局应返回2个位置");
        Debug.Log("✓ Layout 模块正常");

        // ── 6. JSON 序列化 ──
        var serializer = new JsonGraphSerializer();
        string json = serializer.Serialize(graph);
        Debug.Assert(!string.IsNullOrEmpty(json), "序列化结果不应为空");
        Debug.Assert(json.Contains(nodeA.Id), "JSON 应包含节点ID");

        var restored = serializer.Deserialize(json);
        Debug.Assert(restored != null, "反序列化不应为null");
        Debug.Assert(restored.Nodes.Count == 2, "反序列化应恢复2个节点");
        Debug.Assert(restored.Edges.Count == 1, "反序列化应恢复1条连线");
        Debug.Log("✓ Serialization 模块正常");

        Debug.Log("=== NodeGraph 快速测试全部通过 ===");
    }
}
```

**操作**：Unity 菜单 → `Tools > NodeGraph > 运行快速测试`

---

## 3. 刷怪蓝图编辑器窗口测试

### 3.1 打开窗口

Unity 菜单 → `Window > NodeGraph > 刷怪蓝图编辑器`

应看到欢迎页面，包含：
- **导入 SpawnPlan** ObjectField
- **加载 GraphAsset** ObjectField  
- **创建空白蓝图** 按钮

### 3.2 创建空白蓝图

1. 点击 **"创建空白蓝图"**
2. 应看到画布上出现一个绿色的 **"开始"** 节点
3. 工具栏显示：节点 1 / 连线 0 / 选中 0

### 3.3 导入现有 SpawnPlan

1. 将项目中已有的 `SpawnPlanAsset` 拖入 **"导入 SpawnPlan"** 字段
2. 应看到：
   - 绿色 **Start** 节点
   - 橙色 **SpawnTask** 节点（每个任务一个）
   - 节点间根据 `DependsOn` 关系自动连线
   - TreeLayout 自动从左到右排列
3. 工具栏应显示正确的节点/连线数量

### 3.4 基本交互测试

| 操作 | 预期结果 |
|------|----------|
| 滚轮缩放 | 画布缩放 |
| 中键/Alt+左键拖拽 | 画布平移 |
| 左键拖拽空白区域 | 框选矩形 |
| 点击节点 | 选中节点 |
| 点击 **"自动布局"** | 节点重新排列为树形 |
| 点击 **"聚焦全部"** | 视口缩放以显示所有节点 |
| 点击 **"导出"** | Console 输出任务依赖关系 |

### 3.5 小地图

- 窗口右下角应显示小地图（半透明缩略图）
- 小地图中白色矩形代表当前视口
- 点击小地图可快速跳转

---

## 4. 通用 NodeGraph 编辑器测试

Unity 菜单 → `Window > NodeGraph > Node Graph Editor`（基础编辑器窗口）

### 4.1 GraphAsset 创建

1. Project 窗口右键 → `Create > NodeGraph > Graph Asset`
2. 生成 `.asset` 文件
3. 拖入编辑器窗口的 GraphAsset 字段

### 4.2 保存/加载

1. 在编辑器中操作图后，点击 **"保存"**
2. 关闭再重新打开窗口
3. 重新加载同一 GraphAsset
4. 验证图结构是否完整恢复

---

## 5. 程序集依赖验证

确认 10 个 asmdef 正确编译：

| 程序集 | 引擎依赖 | 平台 |
|--------|----------|------|
| NodeGraph.Math | 无 | 全平台 |
| NodeGraph.Core | 无 | 全平台 |
| NodeGraph.Commands | 无 | 全平台 |
| NodeGraph.Abstraction | 无 | 全平台 |
| NodeGraph.View | 无 | 全平台 |
| NodeGraph.Serialization | 无 | 全平台 |
| NodeGraph.Layout | 无 | 全平台 |
| NodeGraph.Unity | UnityEditor | Editor |
| NodeGraph.SpawnBlueprint | UnityEditor + StageDesigner | Editor |

---

## 6. 已知限制

- SpawnBlueprint 模块依赖 `StageDesigner.Editor` 程序集，如果该模块有编译错误会导致 SpawnBlueprint 也无法编译
- 内容渲染器（ContentRenderer）目前为只读显示，暂不支持内嵌编辑（`SupportsInlineEdit = false`）
- 连线标签点击暂未实现（`HandleLabelClick` 返回 false）
- 力导向布局（ForceDirectedLayout）200 次迭代可能对大型图较慢
